type id = int;

type view =
  | AllTodos
  | ActiveTodos
  | CompletedTodos;

type msg =
  | EditNewTodo(string)
  | AddNewTodo
  | HoverTodo(id)
  | StartEditingTodo(id)
  | EditTodo(id, string)
  | DoneEditingTodo(id)
  | ToggleTodo(id)
  | DeleteTodo(id)
  | View(view)
  | ToggleAll
  | ClearCompleted;

type todo = {
  id: int,
  done_: bool,
  text: string,
  hovered: bool,
  editing: bool,
};

type state = {
  todos: list(option(todo)),
  newTodoText: string,
  viewing: view,
  nextId: int,
};

let initialState = {todos: [], newTodoText: "", viewing: AllTodos, nextId: 0};

let updateTodo = (f, todos, id) => {
  let before = List.take(id, todos);
  switch (List.drop(id, todos)) {
  | [target, ...rest] => before @ [f(target)] @ rest
  | _ => todos
  };
};

let activeCount = state =>
  state.todos
  |> List.filter_map(
       Option.flat_map(t =>
         if (t.done_) {
           None;
         } else {
           Some(t);
         }
       ),
     )
  |> List.length;

let completedCount = state =>
  state.todos
  |> List.filter_map(
       Option.flat_map(t =>
         if (t.done_) {
           Some(t);
         } else {
           None;
         }
       ),
     )
  |> List.length;

let totalCount = state =>
  state.todos |> List.filter_map(t => t) |> List.length;

let shownTodos = state => {
  let flat_m = t =>
    switch (state.viewing, t.done_) {
    | (AllTodos, _) => Some(t)
    | (ActiveTodos, false) => Some(t)
    | (CompletedTodos, true) => Some(t)
    | _ => None
    };
  let fil_m = ot => Option.flat_map(flat_m, ot);
  List.filter_map(fil_m, state.todos);
};

let update = (msg, state) =>
  switch (msg) {
  | EditNewTodo(text) => {...state, newTodoText: text}
  | AddNewTodo =>
    let newTodo = {
      id: state.nextId,
      done_: false,
      text: state.newTodoText,
      hovered: false,
      editing: false,
    };
    let newState = {
      ...state,
      nextId: state.nextId + 1,
      newTodoText: "",
      todos: List.append(state.todos, [Some(newTodo)]),
    };
    newState;
  | HoverTodo(id) => {
      ...state,
      todos:
        updateTodo(Option.map(t => {...t, hovered: true}), state.todos, id),
    }
  | StartEditingTodo(id) => {
      ...state,
      todos:
        updateTodo(Option.map(t => {...t, editing: true}), state.todos, id),
    }
  | EditTodo(id, text) => {
      ...state,
      todos: updateTodo(Option.map(t => {...t, text}), state.todos, id),
    }
  | DoneEditingTodo(id) => {
      ...state,
      todos:
        updateTodo(Option.map(t => {...t, editing: false}), state.todos, id),
    }
  | ToggleTodo(id) => {
      ...state,
      todos:
        updateTodo(
          Option.map(t => {...t, done_: !t.done_}),
          state.todos,
          id,
        ),
    }
  | ToggleAll =>
    let anyNotDone =
      List.exists(
        ot =>
          switch (ot) {
          | None => false
          | Some(t) => !t.done_
          },
        state.todos,
      );
    {
      ...state,
      todos:
        List.map(Option.map(t => {...t, done_: anyNotDone}), state.todos),
    };
  | DeleteTodo(id) => {
      ...state,
      todos: updateTodo(_t => None, state.todos, id),
    }
  | View(type_) => {...state, viewing: type_}
  | ClearCompleted => {
      ...state,
      todos:
        state.todos
        |> List.map(
             Option.flat_map(t =>
               if (t.done_) {
                 None;
               } else {
                 Some(t);
               }
             ),
           ),
    }
  };

[@auto]
[@rw]
[@imandra_theorem]
let len_append = (x, y) =>
  List.length(x @ y) == List.length(x) + List.length(y);

let vg_add_todo = s => {
  let s' = update(AddNewTodo, s);
  List.length(s'.todos) == List.length(s.todos) + 1;
};

let vg_update_todo = (todos, n) => {
  let todos' =
    updateTodo(x => Option.map(t => {...t, text: "updated"}, x), todos, n);
  n > 0
  && (
    switch (List.nth(n, todos)) {
    | Some(Some(_)) => true
    | _ => false
    }
  )
  ==> (
    switch (List.nth(n, todos')) {
    | Some(Some(t)) => t.text == "updated"
    | _ => false
    }
  );
};
