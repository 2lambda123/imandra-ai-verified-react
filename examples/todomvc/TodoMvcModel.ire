type id = int;

type view =
  | AllTodos
  | ActiveTodos
  | CompletedTodos;

type msg =
  | EditNewTodo(string)
  | AddNewTodo
  | HoverTodo(id)
  | StartEditingTodo(id)
  | EditTodo(id, string)
  | DoneEditingTodo(id)
  | ToggleTodo(id)
  | DeleteTodo(id)
  | View(view)
  | ToggleAll
  | ClearCompleted;

type todo = {
  id: int,
  done_: bool,
  text: string,
  hovered: bool,
  editing: bool,
};

type state = {
  todos: list(option(todo)),
  newTodoText: string,
  viewing: view,
  nextId: int,
};

let initialState = {todos: [], newTodoText: "", viewing: AllTodos, nextId: 0};

let updateTodo = (f, state, id) => {
  let before = List.take(id, state.todos);
  switch (List.drop(id, state.todos)) {
  | [target, ...rest] => Ok({...state, todos: before @ [f(target)] @ rest})
  | _ => Error("No todo with id")
  };
};

let activeCount = state =>
  state.todos
  |> List.filter_map(
       Option.flat_map(t =>
         if (t.done_) {
           None;
         } else {
           Some(t);
         }
       ),
     )
  |> List.length;

let completedCount = state =>
  state.todos
  |> List.filter_map(
       Option.flat_map(t =>
         if (t.done_) {
           Some(t);
         } else {
           None;
         }
       ),
     )
  |> List.length;

let totalCount = state =>
  state.todos |> List.filter_map(t => t) |> List.length;

let shownTodos = state => {
  let flat_m = t =>
    switch (state.viewing, t.done_) {
    | (AllTodos, _) => Some(t)
    | (ActiveTodos, false) => Some(t)
    | (CompletedTodos, true) => Some(t)
    | _ => None
    };
  let fil_m = ot => Option.flat_map(flat_m, ot);
  List.filter_map(fil_m, state.todos);
};

let update = (msg, state) =>
  switch (msg) {
  | EditNewTodo(text) => Ok({...state, newTodoText: text})
  | AddNewTodo =>
    let newTodo = {
      id: state.nextId,
      done_: false,
      text: state.newTodoText,
      hovered: false,
      editing: false,
    };
    let newState = {
      ...state,
      nextId: state.nextId + 1,
      newTodoText: "",
      todos: List.append(state.todos, [Some(newTodo)]),
    };
    Ok(newState);
  | HoverTodo(id) =>
    updateTodo(Option.map(t => {...t, hovered: true}), state, id)
  | StartEditingTodo(id) =>
    updateTodo(Option.map(t => {...t, editing: true}), state, id)
  | EditTodo(id, text) =>
    updateTodo(Option.map(t => {...t, text}), state, id)
  | DoneEditingTodo(id) =>
    updateTodo(Option.map(t => {...t, editing: false}), state, id)

  | ToggleTodo(id) =>
    updateTodo(Option.map(t => {...t, done_: !t.done_}), state, id)
  | ToggleAll =>
    let anyNotDone =
      List.exists(
        ot =>
          switch (ot) {
          | None => false
          | Some(t) => !t.done_
          },
        state.todos,
      );
    Ok({
      ...state,
      todos:
        List.map(Option.map(t => {...t, done_: anyNotDone}), state.todos),
    });
  | DeleteTodo(id) => updateTodo(_t => None, state, id)
  | View(type_) => Ok({...state, viewing: type_})
  | ClearCompleted =>
    Ok({
      ...state,
      todos:
        state.todos
        |> List.map(
             Option.flat_map(t =>
               if (t.done_) {
                 None;
               } else {
                 Some(t);
               }
             ),
           ),
    })
  };

[@auto]
[@rw]
[@imandra_theorem]
let len_append = (x, y) =>
  List.length(x @ y) == List.length(x) + List.length(y);

let vg_add_todo = s =>
  switch (update(AddNewTodo, s)) {
  | Ok(s') => List.length(s'.todos) == List.length(s.todos) + 1
  | _ => false
  };

let vg_update_todo = (state, n) =>
  switch (update(EditTodo(n, "update"), state)) {
  | Ok(state') =>
    switch (List.nth(n, state'.todos)) {
    | Some(Some(t)) => t.text == "updated"
    | _ => false
    }
  | _ => false
  };
